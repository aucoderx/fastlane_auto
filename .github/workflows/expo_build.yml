name: Expo IOS Build and Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Choose environment (prod or test)'
        required: true
        default: 'test'
      projectID:
        description: 'project id'
        required: true
        default: ''
      needScreengrab:
        description: 'need screengrab'
        required: true
        default: 'false'
      isFirstRun:
        description: 'is first run'
        required: true
        default: 'false'
      appUploadCommand:
        description: 'app upload command'
        required: false
        default: 'test_flight'
      language:
        description: 'app use language'
        required: false
        default: 'zh-Hans'

jobs:
  main-task:
    runs-on: macos-15
    timeout-minutes: 40
    permissions:
      contents: read
    outputs:
      # 定义一个 job 的输出，用于通知步骤
      lock_status: ${{ steps.acquire_lock.outputs.status }}
      job_conclusion: ${{ job.status }}

    steps:
      # 拉取配置代码
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install applesimutils
        run: |
          brew tap wix/brew && brew install applesimutils
          brew install redis
      
      - name: Parse SECRET
        id: parse
        run: |
          # 使用管道避免写入文件系统
          ENV_FILE="fastlane_templates/.env"

          AWS_ID=$(echo '${{ secrets.S3_SECRET }}' | jq -r '.aws_access_key_id')
          AWS_KEY=$(echo '${{ secrets.S3_SECRET }}' | jq -r '.aws_secret_access_key')
          AWS_REG=$(echo '${{ secrets.S3_SECRET }}' | jq -r '.region_name')
          BUCKET=$(echo '${{ secrets.S3_SECRET }}' | jq -r '.bucket_name')

          echo "AWS_ACCESS_KEY_ID=$AWS_ID" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_KEY" >> $GITHUB_ENV
          echo "AWS_REGION=$AWS_REG" >> $GITHUB_ENV
          echo "BUCKET_NAME=$BUCKET" >> $GITHUB_ENV

          sed -i '' "s|^AWS_ACCESS_KEY_ID=.*|AWS_ACCESS_KEY_ID='${AWS_ID}'|" $ENV_FILE
          sed -i '' "s|^AWS_SECRET_ACCESS_KEY=.*|AWS_SECRET_ACCESS_KEY='${AWS_KEY}'|" $ENV_FILE
          sed -i '' "s|^AWS_REGION=.*|AWS_REGION='${AWS_REG}'|" $ENV_FILE
          sed -i '' "s|^BUCKET_NAME=.*|BUCKET_NAME='${BUCKET}'|" $ENV_FILE

          # redis
          echo "REDIS_HOST=$(echo '${{ secrets.REDIS_CONF }}' | jq -r '.redis_host')" >> $GITHUB_ENV
          echo "REDIS_PORT=$(echo '${{ secrets.REDIS_CONF }}' | jq -r '.redis_port')" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=$(echo '${{ secrets.REDIS_CONF }}' | jq -r '.password')" >> $GITHUB_ENV

      - name: '生成唯一的 Lock Key'
        id: lock_key_generator
        run: |
          # 将输入参数组合并通过 sha256sum 生成一个固定的、唯一的 key
          # 这样可以确保相同参数的请求生成相同的 key
          LOCK_KEY="github-action-lock:${{ github.event.inputs.environment }}-${{ github.event.inputs.projectID }}-ios"
          echo "Generated Lock Key: $LOCK_KEY"
          echo "lock_key=$LOCK_KEY" >> $GITHUB_OUTPUT

      - name: '尝试获取 Redis 锁'
        id: acquire_lock
        run: |
          LOCK_VALUE="${{ github.run_id }}-${{ github.run_attempt }}"
          LOCK_TIMEOUT=1800 # 30分钟
          RESULT=$(redis-cli \
            -h ${{ env.REDIS_HOST }} \
            -p ${{ env.REDIS_PORT }} \
            -a ${{ env.REDIS_PASSWORD }} \
            SET ${{ steps.lock_key_generator.outputs.lock_key }} "$LOCK_VALUE" NX EX $LOCK_TIMEOUT)

          if [ "$RESULT" == "OK" ]; then
            echo "成功获取锁，将继续执行任务。"
            echo "status=acquired" >> $GITHUB_OUTPUT
          else
            echo "获取锁失败，任务已被锁定。将跳过主要步骤。"
            echo "status=locked" >> $GITHUB_OUTPUT
            exit 1
          fi      

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Select Xcode 16.3
        run: sudo xcode-select -s /Applications/Xcode_16.3.app/Contents/Developer

      # 测试环境，恢复IOS服务账号
      - name: deal test env
        if: ${{ github.event.inputs.environment == 'test' }}
        run: |
          mkdir -p fastlane_templates/certificates/
          printf "%s" "${{ secrets.AUTHKEY_55A9Z23V8S }}" > fastlane_templates/certificates/AuthKey.p8

      # 正式环境，从S3下载IOS认证
      - name: deal prod env
        if: ${{ github.event.inputs.environment == 'prod' }}
        run: |
          mkdir -p fastlane_templates/certificates/
          aws s3 cp s3://${{ env.BUCKET_NAME }}/${{ github.event.inputs.projectID }}/certificates/AuthKey.p8 fastlane_templates/certificates/AuthKey.p8
      
      # 线上环境，下载项目源码
      - name: Download Expo source (for prod environment)
        if: ${{ github.event.inputs.environment == 'prod' }}
        uses: ./.github/actions/download_project
        with:
          env: dev
          project_id: myproject
      
      # 缓存 npm 安装结果，流程执行完的后续节点进行的缓存，如果流程执行失败，缓存会失败
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.2.0
          cache: 'npm'
          cache-dependency-path: './app-demo/package-lock.json'

      - name: Cache Expo CLI
        uses: actions/cache@v4
        with:
          path: ~/.expo
              # 由於 package.json 相同，使用 lock 檔案來決定 Expo 工具鏈的快取
          key: ${{ runner.os }}-expo-${{ hashFiles(format('{0}/package-lock.json', github.event.inputs.appName)) }}
          restore-keys: |
            ${{ runner.os }}-expo-
      
      # npm 安装依赖
      - name: Install dependencies
        run: |
          cd app-demo
          npm install        
        
      # 构建IOS源码
      - name: Build for iOS
        run: |
          cd app-demo
          npx expo prebuild --platform ios
         

      # 执行fastlane配置脚本
      - name: exec manage_fastlane.sh
        run: |
          ./manage_fastlane.sh app-demo ios
    
      # IOS包构建
      - name: ios build
        run: |
          cd app-demo/ios
          #./fastlane/deploy_ios.sh build_only

      # 下载证书并安装到钥匙链
      - name: ios certificate
        run: | 
          if [ "${{ github.event.inputs.isFirstRun }}" == "true" ]; then
            MATCH_PASSWORD="autocoder.cc123" fastlane match appstore   
          fi
      
      #IOS 截屏
      - name: ios screengrab
        if: ${{ github.event.inputs.needScreengrab == 'true' }}
        run: |
          cd app-demo/ios
          ./fastlane/deploy_ios.sh screengrab

      # IOS 上传
      - name: ios appUpload
        env:
          MATCH_PASSWORD: "autocoder.cc123"
        if: ${{ github.event.inputs.appUploadCommand != '' }}
        run: |
          cd app-demo/ios
          ./fastlane/deploy_ios.sh ${{github.event.inputs.appUploadCommand}}

      - name: Upload Screenshots and Logs
        if: always()  
        uses: actions/upload-artifact@v4
        with:
          name: detox-debug-artifacts
          path: |
            app-demo/ios/fastlane
          retention-days: 5
      


      - name: '释放 Redis 锁'
        # 使用 if: always() 确保无论任务成功还是失败，都会尝试释放锁
        if: always() && steps.acquire_lock.outputs.status == 'acquired'
        run: |
          if [ "${{ steps.acquire_lock.outcome }}" == "success" ]; then
            redis-cli \
              -h ${{ env.REDIS_HOST }} \
              -p ${{ env.REDIS_PORT }} \
              -a ${{ env.REDIS_PASSWORD }} \
              DEL ${{ steps.lock_key_generator.outputs.lock_key }}
            echo "锁已释放。"
          else
            echo "未曾获取锁，无需释放。"
          fi
  

  # 使用一个独立的 Job 来处理通知，这样逻辑更清晰
  # 它依赖于 main-task job，并在其完成后运行
  notify-server:
    runs-on: ubuntu-latest
    needs: main-task # 依赖 main-task job
    if: always() # 无论 main-task 成功、失败还是被跳过，都运行此 job

    steps:
      - name: '发送任务完成情况通知'
        run: |
          LOCK_STATUS="${{ needs.main-task.outputs.lock_status }}"
          JOB_CONCLUSION="${{ needs.main-task.outputs.job_conclusion }}"
          
          # 决定最终的通知状态
          FINAL_STATUS=""
          if [ "$LOCK_STATUS" == "locked" ]; then
            FINAL_STATUS="skipped_due_to_lock"
            echo "任务因锁定被跳过。"
          elif [ "$JOB_CONCLUSION" == "success" ]; then
            FINAL_STATUS="success"
            echo "任务执行成功。"
          else
            # 如果获取了锁，但 job 失败了
            FINAL_STATUS="failure"
            echo "任务执行失败。"
          fi
          